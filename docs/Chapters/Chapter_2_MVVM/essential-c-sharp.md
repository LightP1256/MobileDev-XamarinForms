[Contents](README.md)

----

[Prev](README.md)

# Essential C#
As in the previous chapter, some of the prerequisite C#.NET knowledge is covered. You may have met some of this before, in which case consider this useful revision.

Topics Include:

   1. [Anonymous Functions](anonymous-functions.md). You may have written many _instance methods_ or _static / class methods_ by now, both of which are a type of _function_. Functions in C#.NET are not just program code, but are data structures, and are sometimes also said to be _first class types_. This means a _function_ type can be passed as a parameter, returned from another function or referenced in a variable (maybe for later use). This may seem very strange, especially if you are coming from older languages, but it's a powerful language feature that has many useful applications. First-class functions also have a useful behavior known as "capturing" which will also be explained. If we are not careful, we could easily end up in a long discussion about _functional programming_. For all its merits and criticisms (yes, it can get a bit opinionated out there), this is _not_ a course in functional programming. Instead, this topic is being covered firstly because it is a perquisite for some of the APIs we will be using (and is transferrable to many other modern languages), and secondly, you may like it and want to pursue it further. If you are a big  advocate of function programming, I hear that F# is nice.

   1. [Asynchronous Programming - async and await](async-programming.md). When you first learn to program, you probably write operations in a particular sequence, and expect those operations to be performed in the exact same sequence. This is fine for simple tasks and is still the most common type of code used. However, this approach presents challenges when you need to interact with hardware which is significantly slower than the CPU. You may wonder why this is relevant to mobile app development. Well, you are always interacting with hardware as a phone is an electronic device (a CPU + peripheral devices). Slow hardware commonly includes persistent storage (especially when writing), hardware timers (to implement delays) and network interface devices (internet access can take many seconds to respond). If you perform data transactions with any such device, at some point in your code the CPU is going to have to wait for the transaction to complete. At the same time, other tasks such as user interfaces (and the respective screen touch sensor) need to remain fast and responsive. _If we were stop and wait for a slow hardware transaction in our code (such as in an event handler), this would render the UI unresponsive and may even cause the app to be kicked by the host operating system_. The traditional solution is to use some form of multi-tasking, often by running multiple _threads_ of code at the same time. The main UI code might run on one thread, and a (slow) hardware transaction is performed on another another. This way, the slow hardware operation would not adversely interfere with the UI code timing. Such facilities are available even on a single core CPU (in fact, this concept predates multi-core by many years). 
   A problem with this approach is one of safe and correct synchronization between the parallel threads of code, especially where they share any writable information (this is a whole topic in itself!). Rather than rely on the developer to write complex (and potentially buggy) multi-threaded code, the notion of an asynchronous API is introduced, along with an excellent language feature `await` and `async`. This is a radically different approach, that does **NOT** have to involve multi-threaded programming (but does not exclude it either). It also allows you to continue writing code in a sequence as you always did. How does this work? The clue is that hardware devices run in parallel to the CPU. The CPU does not bother to wait for a device to complete a transaction, so is free to maintain other services (such as UI). However, it does need to know when when the hardware is finished in the form of an event (like tapping a button). I will try and explain with examples. I found this approach somewhat enlightening - I hope you will like it too!

   1. [Loose Coupling with Interfaces](loose-coupling.md). You may have used C# interfaces or seen them used in examples. You might be wondering _what's the point?_ Surely it's a bit like a class, but with no actual code or data? Well, interfaces are more than that, and one of the most heavily used Object Orientated Programming language features in C# (and other languages). One of the key reasons to use them is to avoid "Tight Coupling" between objects. This means, one object may need to reference another with a known and guaranteed set of capabilities, but without the need to know the actual concrete class type. Again, _so what_ I hear you say! Well, this is useful when we wish to switch different code in and out of our project, or update classes without breaking other parts of the project. This results in simpler and shorter code, which is a good thing right? 
   You can think of interfaces as guaranteed lists of capabilities that can be attached to objects (and enforced). As an analogy, we recognize steer, speed up and slow down as capabilities of a car interface (steering wheel and pedals make up the basic physical interface to a car). For the purposes of driving the car safely, the exact type of the engine and transmission system is fundamentally of no interest to the driver (ok, to most drivers). An engine could be swapped out for another and the driver could still drive with the same operations (and no additional training). We could say the driver is loosely coupled to the car. When the driver buys a new car, they don't have to fundamentally change (ok, as ever life is more complex than this, but hopefully you get the point). Equally, the complete interface must be visibly present driver before we even buy the car - we would not buy a car without brake pedal for example, so it is also (type) safe at that level through enforcement of standards. 
   Another (and possibly better) example might be a rendering object. It might have two capabilities, "create new page" and "draw image". A printer object and a screen object are physically very different, but both offer these same capabilities. These objects would each "implement" an interface specifying "create new page" and "draw image". The code in each would differ, but semantically, they do the same thing. Furthermore, these objects won't compile until these interfaces are implemented. A component of a word processor may have a reference to a renderer. At any point in the code, that reference can be safely directed to either a screen or printer object. It can safely draw to it without knowing or caring which physical device it is. You could even hold a list of Renderers, with each entry referencing any concrete object that implements (aka conforms-to) the Renderer interface. Of course, any unique capabilities of the printer or screen would not be visible (unless you get into introspection, but that's a topic for another time).
   This might all sound a bit mysterious / nonsense-like, but hopefully with a few simple practical examples, this will become clear. 

   1. [Handling Exceptions with Try-Catch](try-catch.md). Error handling can easily be demoted to the "I'll deal with it later (and probably forget)" bin. As an educator, you might expect me to revert to a scolding / patronizing tone, but it's probably helpful to face facts and note this is a very human thing to do. While the core logic of your code is still evolving, you might be reluctant to cover all edge-cases only to change it all again. When it comes to writing error handling, this can easily result in deeply nested conditional statements which quickly turn into a mess (also known as the _pyramid of hell_). It does not have to be this way. The Try-Catch language feature is a very powerful way to catch errors at run time and handle them gracefully, without the spaghetti code and it's easy to get started. Some APIs will require you to use Try-Catch. Even if you don't ever _throw and exception_ yourself, others might. Even if you can't throw, you still need to catch. Again, example should make this clearer.

[Next - Anonymous Functions](anonymous-functions.md)

----

[Contents](/docs/README.md)